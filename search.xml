<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>仙人掌图专题</title>
      <link href="/2018/11/03/xian-ren-zhang-tu-zhuan-ti/"/>
      <url>/2018/11/03/xian-ren-zhang-tu-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><ul><li>本文基本转载，极少原创，转载来源见Reference</li></ul><h2 id="DFS树"><a href="#DFS树" class="headerlink" title="DFS树"></a>DFS树</h2><ul><li><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>仙人掌图：每条边至多在一个环上的图。</p><p>仙人掌图中每个环相当于一个点双连通分量，那么用Tarjan算法处理dfs树。</p><p>对于树边$(low[y]&gt;fn[x])$直接处理，环边先忽略。</p><p>每个环只在其深度最小的点$x$处理，设深度最大的点为$y$，则找到$(x,y)$并进行处理$(fa[y] \neq x \ and\ dfn[y]&gt;dfn[x])$。</p></li><li><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>  <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1023" target="_blank" rel="noopener">[SHOI2008]cactus仙人掌图</a> </p><blockquote><p>给定仙人掌图（每条边至多在一个简单环上），求直径（最长的点对最短路径）。$n\leq 50000,m\leq {10}^{7}$。</p></blockquote><p>  对仙人掌建立DFS树，参考无向图的点双连通分量Tarjan算法，在访问$x$时容易知道边$(x,y)$是否属于一个环。</p><p>  设$f[x]$表示$x$点向下延伸的最长链长度，对于不在环上的边$(x,y)$，有$f[x]=\max \lbrace f[y]+1 \rbrace $。统计直径可以在访问每个$y$时进行$ans=\max \lbrace ans,f[x]+f[y]+1\rbrace $从而完成子树$x$对答案的贡献。</p><p>  对于一个环，只在其DFS树中深度最小的点进行处理（其它点直接忽略环边的存在），假设当前这个点为$x$，其与深度最大的点$y$的连边为$(x,y)$。（这条边只要满足$(fa[y] \neq x \ and\ dfn[y]&gt;dfn[x])$就可以找到）</p><p>  假设这个环有$cnt$个点，在环上只有距离$&lt;=\frac{cnt}{2}$的点对可以贡献答案。我们只需要维护每个点和其前面半圈的点构成的点对中的最大值，这可以用单调队列维护。</p><p>  但这样的话，前半圈的点与前面的点对会少考虑一部分，所以将环延伸半圈，即维护一圈半的点。最后记得枚举整个环更新$f[x]$。</p><p>  复杂度$O(m)$。</p><pre class=" language-c++"><code class="language-c++">#include<cstdio>#include<cstring>#include<cctype>#include<algorithm>using namespace std;int read(){    char c;int s=0,t=1;    while(!isdigit(c=getchar()))if(c=='-')t=-1;    do{s=s*10+c-'0';}while(isdigit(c=getchar()));    return s*t;}const int maxn=100010,maxm=20000010;struct edge{int v,from;}e[maxm];int first[maxn],tot,fa[maxn],a[maxn],f[maxn],q[maxn],dfn[maxn],low[maxn],ans,dfsnum=0,n,m;void insert(int u,int v){tot++;e[tot].v=v;e[tot].from=first[u];first[u]=tot;}void solve(int A,int B){    int cnt=0;    for(int i=B;i!=A;i=fa[i])a[++cnt]=f[i];a[++cnt]=f[A];    for(int i=1;i<=cnt/2;i++)swap(a[i],a[cnt-i+1]);    for(int i=cnt+1;i<=cnt+(cnt>>1);i++)a[i]=a[i-cnt];    int head=0,tail=1;q[head]=1;    for(int i=2;i<=cnt+(cnt>>1);i++){        if(head<tail&&i-q[head]>cnt/2)head++;        ans=max(ans,a[i]+a[q[head]]+i-q[head]);        while(head<tail&&a[i]-i>=a[q[tail-1]]-q[tail-1])tail--;        q[tail++]=i;    }    for(int i=2;i<=cnt;i++)f[A]=max(f[A],a[i]+min(i-1,cnt-i+1));}void dfs(int x,int father){    dfn[x]=low[x]=++dfsnum;f[x]=0;    for(int i=first[x];i;i=e[i].from)if(e[i].v!=father){        int y=e[i].v;        if(!dfn[y]){            fa[y]=x;            dfs(y,x);            low[x]=min(low[x],low[y]);        }else low[x]=min(low[x],dfn[y]);        if(low[y]>dfn[x]){            ans=max(ans,f[x]+f[y]+1);            f[x]=max(f[x],f[y]+1);        }    }    for(int i=first[x];i;i=e[i].from)        if(e[i].v!=father&&fa[e[i].v]!=x&&dfn[e[i].v]>dfn[x])solve(x,e[i].v);}    int main(){    n=read();m=read();    for(int i=1;i<=m;i++){        int k=read(),u=read();        for(int j=2;j<=k;j++){            int v=read();            insert(u,v);insert(v,u);            u=v;        }    }    ans=0;    dfs(1,0);    printf("%d",ans);    return 0;}</code></pre><p>  <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4316" target="_blank" rel="noopener">小C的独立集</a></p><blockquote><p>给定仙人掌图，求最大独立集（选择最大的点集使得点间无连边）。$n\leq 50000,m\leq 60000$。<br>  对仙人掌进行无向图的点双连通分量Tarjan算法，树边正常DP，环边$(low[y]\leq dfn[x])$无视。每个环在其深度最小的点整体处理（找到$(u,v)$只须$fa[v]≠u\ and\ dfn[y]&gt;dfn[x]$）。</p></blockquote><pre class=" language-c++"><code class="language-c++">#include<cstdio>#include<cctype>#include<algorithm>using namespace std;int read(){    char c;int s=0,t=1;    while(!isdigit(c=getchar()))if(c=='-')t=-1;    do{s=s*10+c-'0';}while(isdigit(c=getchar()));    return s*t;}const int maxn=100010;struct edge{int v,from;}e[maxn*2];int n,m,tot,first[maxn],fa[maxn],f[maxn][2],g[maxn][2];int dfn[maxn],low[maxn],dfsnum=0;void insert(int u,int v){tot++;e[tot].v=v;e[tot].from=first[u];first[u]=tot;}void solve(int u,int v){    int cnt=0;    for(int i=v;i!=fa[u];i=fa[i]){cnt++;g[cnt][0]=f[i][0];g[cnt][1]=f[i][1];}    for(int i=2;i<=cnt;i++){        g[i][0]+=max(g[i-1][0],g[i-1][1]);        g[i][1]+=g[i-1][0];    }    f[u][0]=g[cnt][0];    cnt=0;    for(int i=v;i!=fa[u];i=fa[i]){cnt++;g[cnt][0]=f[i][0];g[cnt][1]=f[i][1];}    g[1][1]=-0x3f3f3f3f;    for(int i=2;i<=cnt;i++){        g[i][0]+=max(g[i-1][0],g[i-1][1]);        g[i][1]+=g[i-1][0];    }    f[u][1]=g[cnt][1];}    void tarjan(int x,int father){    dfn[x]=low[x]=++dfsnum;f[x][0]=0;f[x][1]=1;    for(int i=first[x];i;i=e[i].from)if(i!=father){        int y=e[i].v;        if(!dfn[y]){            fa[y]=x;            tarjan(y,i);            low[x]=min(low[x],low[y]);        }else low[x]=min(low[x],dfn[y]);        if(low[y]>dfn[x]){            f[x][0]+=max(f[y][0],f[y][1]);            f[x][1]+=f[y][0];        }    }    for(int i=first[x];i;i=e[i].from)if(fa[e[i].v]!=x&&dfn[e[i].v]>dfn[x])solve(x,e[i].v);}int main(){    n=read();m=read();    for(int i=1;i<=m;i++){        int u=read(),v=read();        insert(u,v);insert(v,u);    }    tarjan(1,0);    printf("%d",max(f[1][0],f[1][1]));    return 0;}</code></pre><h2 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h2></li><li><h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h4><p>  原图每个点都是圆点，非环边直接相连。对于每个环，新建一个方点连接这个环的所有圆点（环边不连）。</p><p>  建图方法同DFS树，在处理环的时候连接方点。取出一个环只要取出方点的所有邻点即可（按顺序）。</p></li><li><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>  <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2125" target="_blank" rel="noopener">最短路</a></p><blockquote><p>给定$n$个人的$a_i$和$b_i$，表示第$i$个人能力值为$a_i$且不能和$b_i$同时选择，求能力值和最大的选择方案。$n \leq 10^6$。</p></blockquote><p>树上的两点间最短路问题，常用倍增求LCA解决，考虑扩展到仙人掌图。</p><p>先对仙人掌图建圆方树，圆圆边和原图边权一致。对于每个方点代表的环，记深度最小的点为$x$，则圆方边的边权是圆点到$x$的最短距离。</p><p>若$lca(u,v)$为圆点，则两点间最短路转化为圆方树上$dis[u]+dis[v]-2*dis[lca]$。（向上延伸的路径，经过环则必然经过每个方点的$x$，计算无误）</p><p>若$lca(u,v)$为方点，则记$u,v$在方点连接的圆点$A,B$的子树内，那么两点间最短路为$dis[u]+dis[v]-dis[A]-dis[B]+dis(A,B)$，$dis(A,B)$是$A,B$在环上的短侧路径。</p><p>复杂度$O(Q\log n)$。</p><p>实现细节：</p><p>1.Tarjan：建圆方树（先处理树边，最后在深度最小处处理环）</p><p>2.处理方点：$s[i]$表示点$i$从所在环点$x$（深度最小）开始逆时针的距离，最终$s[x]$记为$s[N]$后$s[x]=0$。另外注意要记录一下环中点的编号顺序。</p><p>3.LCA：圆点直接计算，方点中$dis(A,B)=\min \lbrace s[A]+s[w]-s[B] , s[B]-s[A] \rbrace$（$A$在$B$的顺时针方向，否则交换$AB$）。</p><p>4.注意防止访问父亲的边是$i\oplus 1$，初始$tot=1$。</p><pre class=" language-c++"><code class="language-c++">#include<cstdio>#include<cstring>#include<algorithm>#define ll long longusing namespace std;const int maxn=20010;int N,fa[maxn],b[maxn],f[maxn][20],dfn[maxn],low[maxn],dfsnum=0,deep[maxn],A,B,n,m,id[maxn];ll s[maxn],dis[maxn];struct tu{    int first[maxn],tot;    struct edge{int v,w,from;}e[maxn*2];    void insert(int u,int v,int w){        tot++;e[tot].v=v;e[tot].w=w;e[tot].from=first[u];first[u]=tot;        tot++;e[tot].v=u;e[tot].w=w;e[tot].from=first[v];first[v]=tot;    }}G;int first[maxn],tot;struct edge{int v,w,from;}e[maxn*2];void insert(int u,int v,int w){    tot++;e[tot].v=v;e[tot].w=w;e[tot].from=first[u];first[u]=tot;    tot++;e[tot].v=u;e[tot].w=w;e[tot].from=first[v];first[v]=tot;}void solve(int u,int v,int w){    N++;    int pre=w,ID=0;    for(int i=v;i!=fa[u];i=fa[i]){        s[i]=pre;        pre+=b[i];        id[i]=ID++;    }    s[N]=s[u];s[u]=0;    for(int i=v;i!=fa[u];i=fa[i])insert(N,i,min(s[i],s[N]-s[i]));}void tarjan(int x,int father){    dfn[x]=low[x]=++dfsnum;    for(int i=G.first[x];i;i=G.e[i].from)if(i!=father){        int y=G.e[i].v;        if(!dfn[y]){            fa[y]=x;b[y]=G.e[i].w;            tarjan(G.e[i].v,i^1);            low[x]=min(low[x],low[y]);        }else low[x]=min(low[x],dfn[y]);        if(low[y]>dfn[x])insert(x,y,G.e[i].w);    }    for(int i=G.first[x];i;i=G.e[i].from){        int y=G.e[i].v;        if(fa[y]!=x&&dfn[y]>dfn[x])solve(x,y,G.e[i].w);    }}void dfs(int x,int father){    for(int j=1;(1<<j)<=deep[x];j++)f[x][j]=f[f[x][j-1]][j-1];    for(int i=first[x];i;i=e[i].from)if(i!=father){        f[e[i].v][0]=x;        deep[e[i].v]=deep[x]+1;        dis[e[i].v]=dis[x]+e[i].w;        dfs(e[i].v,i^1);    }}int lca(int x,int y){    if(deep[x]<deep[y])swap(x,y);    int d=deep[x]-deep[y];    for(int i=0;(1<<i)<=d;i++)if(d&(1<<i))x=f[x][i];    if(x==y)return x;    for(int i=20;i>=0;i--)if((1<<i)<=deep[x]&&f[x][i]!=f[y][i]){        x=f[x][i];y=f[y][i];    }    A=x;B=y;    return f[x][0];}int main(){    int Q;    scanf("%d%d%d",&n,&m,&Q);    int u,v,w;    G.tot=1;tot=1;    for(int i=1;i<=m;i++){        scanf("%d%d%d",&u,&v,&w);        G.insert(u,v,w);    }    N=n;tarjan(1,0);dfs(1,0);    while(Q--){        scanf("%d%d",&u,&v);        w=lca(u,v);        if(w<=n)printf("%lld\n",dis[u]+dis[v]-2*dis[w]);        else{            ll ans=dis[u]+dis[v]-dis[A]-dis[B];            if(id[A]<id[B])ans+=min(s[A]+s[w]-s[B],s[B]-s[A]);                else ans+=min(s[B]+s[w]-s[A],s[A]-s[B]);            printf("%lld\n",ans);        }    }    return 0;}</code></pre><h2 id="点双"><a href="#点双" class="headerlink" title="点双"></a>点双</h2><p>对于无向连通图，对每个点双建立一个方点连向其中所有点并消除点双内部的连边，这样就是广义圆方树。</p><p>例如经典的旅行问题：询问带点权无向图中，两点间所有简单路径的最小权值。</p><p>两点间的简单路径并=两点间的唯一点双链。（如果存在一条其它路径到达，则与已有点双矛盾。）</p><p>所以建立广义圆方树后就是查询树链最小值的问题了。（每个方点的权=连接圆点的最小权）</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.cnblogs.com/onioncyc/p/8315835.html" target="_blank" rel="noopener">【算法专题】仙人掌图问题</a></li><li><a href="https://blog.csdn.net/zhangche0526/article/details/71879985" target="_blank" rel="noopener">仙人掌相关问题的处理方法（未完待续）</a></li><li><a href="https://download.csdn.net/download/simpsonk/10172077" target="_blank" rel="noopener">WC2017-immortalCO Making Graph into Trees</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI/ACM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/02/hello-world/"/>
      <url>/2018/11/02/hello-world/</url>
      
        <content type="html"><![CDATA[<pre class=" language-C++"><code class="language-C++">#include <stdio.h>int main(){    printf("Hello, World!\n");    return 0;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
