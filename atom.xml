<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>理想之国 | Li Xiang&#39;s blog</title>
  
  <subtitle>Li Xiang&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lixiang-io.cn/"/>
  <updated>2019-02-18T14:12:56.987Z</updated>
  <id>https://lixiang-io.cn/</id>
  
  <author>
    <name>Li Xiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>仙人掌图专题</title>
    <link href="https://lixiang-io.cn/2018/11/03/%E4%BB%99%E4%BA%BA%E6%8E%8C%E5%9B%BE%E4%B8%93%E9%A2%98/"/>
    <id>https://lixiang-io.cn/2018/11/03/仙人掌图专题/</id>
    <published>2018-11-03T13:17:00.000Z</published>
    <updated>2019-02-18T14:12:56.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><ul><li>本文基本转载，极少原创，转载来源见Reference</li></ul><h2 id="DFS树"><a href="#DFS树" class="headerlink" title="DFS树"></a>DFS树</h2><ul><li><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>仙人掌图：每条边至多在一个环上的图。</p><p>仙人掌图中每个环相当于一个点双连通分量，那么用Tarjan算法处理dfs树。</p><p>对于树边$(low[y]&gt;fn[x])$直接处理，环边先忽略。</p><p>每个环只在其深度最小的点$x$处理，设深度最大的点为$y$，则找到$(x,y)$并进行处理$(fa[y] \neq x \ and\ dfn[y]&gt;dfn[x])$。</p></li><li><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>  <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1023" target="_blank" rel="noopener">[SHOI2008]cactus仙人掌图</a> </p><blockquote><p>给定仙人掌图（每条边至多在一个简单环上），求直径（最长的点对最短路径）。$n\leq 50000,m\leq {10}^{7}$。</p></blockquote><p>  对仙人掌建立DFS树，参考无向图的点双连通分量Tarjan算法，在访问$x$时容易知道边$(x,y)$是否属于一个环。</p><p>  设$f[x]$表示$x$点向下延伸的最长链长度，对于不在环上的边$(x,y)$，有$f[x]=\max \lbrace f[y]+1 \rbrace $。统计直径可以在访问每个$y$时进行$ans=\max \lbrace ans,f[x]+f[y]+1\rbrace $从而完成子树$x$对答案的贡献。</p><p>  对于一个环，只在其DFS树中深度最小的点进行处理（其它点直接忽略环边的存在），假设当前这个点为$x$，其与深度最大的点$y$的连边为$(x,y)$。（这条边只要满足$(fa[y] \neq x \ and\ dfn[y]&gt;dfn[x])$就可以找到）</p><p>  假设这个环有$cnt$个点，在环上只有距离$&lt;=\frac{cnt}{2}$的点对可以贡献答案。我们只需要维护每个点和其前面半圈的点构成的点对中的最大值，这可以用单调队列维护。</p><p>  但这样的话，前半圈的点与前面的点对会少考虑一部分，所以将环延伸半圈，即维护一圈半的点。最后记得枚举整个环更新$f[x]$。</p><p>  复杂度$O(m)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;<span class="keyword">int</span> s=<span class="number">0</span>,t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c=getchar()))<span class="keyword">if</span>(c==<span class="string">'-'</span>)t=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;s=s*<span class="number">10</span>+c-<span class="string">'0'</span>;&#125;<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c=getchar()));</span><br><span class="line">    <span class="keyword">return</span> s*t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>,maxm=<span class="number">20000010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,from;&#125;e[maxm];</span><br><span class="line"><span class="keyword">int</span> first[maxn],tot,fa[maxn],a[maxn],f[maxn],q[maxn],dfn[maxn],low[maxn],ans,dfsnum=<span class="number">0</span>,n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;tot++;e[tot].v=v;e[tot].from=first[u];first[u]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> A,<span class="keyword">int</span> B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=B;i!=A;i=fa[i])a[++cnt]=f[i];a[++cnt]=f[A];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt/<span class="number">2</span>;i++)swap(a[i],a[cnt-i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt+<span class="number">1</span>;i&lt;=cnt+(cnt&gt;&gt;<span class="number">1</span>);i++)a[i]=a[i-cnt];</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;q[head]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cnt+(cnt&gt;&gt;<span class="number">1</span>);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head&lt;tail&amp;&amp;i-q[head]&gt;cnt/<span class="number">2</span>)head++;</span><br><span class="line">        ans=max(ans,a[i]+a[q[head]]+i-q[head]);</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;a[i]-i&gt;=a[q[tail<span class="number">-1</span>]]-q[tail<span class="number">-1</span>])tail--;</span><br><span class="line">        q[tail++]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)f[A]=max(f[A],a[i]+min(i<span class="number">-1</span>,cnt-i+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfsnum;f[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first[x];i;i=e[i].from)<span class="keyword">if</span>(e[i].v!=father)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            fa[y]=x;</span><br><span class="line">            dfs(y,x);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">        &#125;<span class="keyword">else</span> low[x]=min(low[x],dfn[y]);</span><br><span class="line">        <span class="keyword">if</span>(low[y]&gt;dfn[x])&#123;</span><br><span class="line">            ans=max(ans,f[x]+f[y]+<span class="number">1</span>);</span><br><span class="line">            f[x]=max(f[x],f[y]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first[x];i;i=e[i].from)</span><br><span class="line">        <span class="keyword">if</span>(e[i].v!=father&amp;&amp;fa[e[i].v]!=x&amp;&amp;dfn[e[i].v]&gt;dfn[x])solve(x,e[i].v);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=read(),u=read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=read();</span><br><span class="line">            insert(u,v);insert(v,u);</span><br><span class="line">            u=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4316" target="_blank" rel="noopener">小C的独立集</a></p><blockquote><p>给定仙人掌图，求最大独立集（选择最大的点集使得点间无连边）。$n\leq 50000,m\leq 60000$。<br>  对仙人掌进行无向图的点双连通分量Tarjan算法，树边正常DP，环边$(low[y]\leq dfn[x])$无视。每个环在其深度最小的点整体处理（找到$(u,v)$只须$fa[v]≠u\ and\ dfn[y]&gt;dfn[x]$）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;<span class="keyword">int</span> s=<span class="number">0</span>,t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c=getchar()))<span class="keyword">if</span>(c==<span class="string">'-'</span>)t=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;s=s*<span class="number">10</span>+c-<span class="string">'0'</span>;&#125;<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c=getchar()));</span><br><span class="line">    <span class="keyword">return</span> s*t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,from;&#125;e[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,tot,first[maxn],fa[maxn],f[maxn][<span class="number">2</span>],g[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn],low[maxn],dfsnum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;tot++;e[tot].v=v;e[tot].from=first[u];first[u]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=v;i!=fa[u];i=fa[i])&#123;cnt++;g[cnt][<span class="number">0</span>]=f[i][<span class="number">0</span>];g[cnt][<span class="number">1</span>]=f[i][<span class="number">1</span>];&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        g[i][<span class="number">0</span>]+=max(g[i<span class="number">-1</span>][<span class="number">0</span>],g[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        g[i][<span class="number">1</span>]+=g[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    f[u][<span class="number">0</span>]=g[cnt][<span class="number">0</span>];</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=v;i!=fa[u];i=fa[i])&#123;cnt++;g[cnt][<span class="number">0</span>]=f[i][<span class="number">0</span>];g[cnt][<span class="number">1</span>]=f[i][<span class="number">1</span>];&#125;</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        g[i][<span class="number">0</span>]+=max(g[i<span class="number">-1</span>][<span class="number">0</span>],g[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        g[i][<span class="number">1</span>]+=g[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    f[u][<span class="number">1</span>]=g[cnt][<span class="number">1</span>];</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfsnum;f[x][<span class="number">0</span>]=<span class="number">0</span>;f[x][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first[x];i;i=e[i].from)<span class="keyword">if</span>(i!=father)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            fa[y]=x;</span><br><span class="line">            tarjan(y,i);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">        &#125;<span class="keyword">else</span> low[x]=min(low[x],dfn[y]);</span><br><span class="line">        <span class="keyword">if</span>(low[y]&gt;dfn[x])&#123;</span><br><span class="line">            f[x][<span class="number">0</span>]+=max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">            f[x][<span class="number">1</span>]+=f[y][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first[x];i;i=e[i].from)<span class="keyword">if</span>(fa[e[i].v]!=x&amp;&amp;dfn[e[i].v]&gt;dfn[x])solve(x,e[i].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=read(),v=read();</span><br><span class="line">        insert(u,v);insert(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    tarjan(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,max(f[<span class="number">1</span>][<span class="number">0</span>],f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h2><ul><li><h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h4><p>  原图每个点都是圆点，非环边直接相连。对于每个环，新建一个方点连接这个环的所有圆点（环边不连）。</p><p>  建图方法同DFS树，在处理环的时候连接方点。取出一个环只要取出方点的所有邻点即可（按顺序）。</p></li><li><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>  <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2125" target="_blank" rel="noopener">最短路</a></p><blockquote><p>给定$n$个人的$a_i$和$b_i$，表示第$i$个人能力值为$a_i$且不能和$b_i$同时选择，求能力值和最大的选择方案。$n \leq 10^6$。</p></blockquote><p>树上的两点间最短路问题，常用倍增求LCA解决，考虑扩展到仙人掌图。</p><p>先对仙人掌图建圆方树，圆圆边和原图边权一致。对于每个方点代表的环，记深度最小的点为$x$，则圆方边的边权是圆点到$x$的最短距离。</p><p>若$lca(u,v)$为圆点，则两点间最短路转化为圆方树上$dis[u]+dis[v]-2*dis[lca]$。（向上延伸的路径，经过环则必然经过每个方点的$x$，计算无误）</p><p>若$lca(u,v)$为方点，则记$u,v$在方点连接的圆点$A,B$的子树内，那么两点间最短路为$dis[u]+dis[v]-dis[A]-dis[B]+dis(A,B)$，$dis(A,B)$是$A,B$在环上的短侧路径。</p><p>复杂度$O(Q\log n)$。</p><p>实现细节：</p><p>1.Tarjan：建圆方树（先处理树边，最后在深度最小处处理环）</p><p>2.处理方点：$s[i]$表示点$i$从所在环点$x$（深度最小）开始逆时针的距离，最终$s[x]$记为$s[N]$后$s[x]=0$。另外注意要记录一下环中点的编号顺序。</p><p>3.LCA：圆点直接计算，方点中$dis(A,B)=\min \lbrace s[A]+s[w]-s[B] , s[B]-s[A] \rbrace$（$A$在$B$的顺时针方向，否则交换$AB$）。</p><p>4.注意防止访问父亲的边是$i\oplus 1$，初始$tot=1$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> N,fa[maxn],b[maxn],f[maxn][<span class="number">20</span>],dfn[maxn],low[maxn],dfsnum=<span class="number">0</span>,deep[maxn],A,B,n,m,id[maxn];</span><br><span class="line">ll s[maxn],dis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tu</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> first[maxn],tot;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,w,from;&#125;e[maxn*<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        tot++;e[tot].v=v;e[tot].w=w;e[tot].from=first[u];first[u]=tot;</span><br><span class="line">        tot++;e[tot].v=u;e[tot].w=w;e[tot].from=first[v];first[v]=tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;G;</span><br><span class="line"><span class="keyword">int</span> first[maxn],tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,w,from;&#125;e[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    tot++;e[tot].v=v;e[tot].w=w;e[tot].from=first[u];first[u]=tot;</span><br><span class="line">    tot++;e[tot].v=u;e[tot].w=w;e[tot].from=first[v];first[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    N++;</span><br><span class="line">    <span class="keyword">int</span> pre=w,ID=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=v;i!=fa[u];i=fa[i])&#123;</span><br><span class="line">        s[i]=pre;</span><br><span class="line">        pre+=b[i];</span><br><span class="line">        id[i]=ID++;</span><br><span class="line">    &#125;</span><br><span class="line">    s[N]=s[u];s[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=v;i!=fa[u];i=fa[i])insert(N,i,min(s[i],s[N]-s[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfsnum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=G.first[x];i;i=G.e[i].from)<span class="keyword">if</span>(i!=father)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=G.e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            fa[y]=x;b[y]=G.e[i].w;</span><br><span class="line">            tarjan(G.e[i].v,i^<span class="number">1</span>);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">        &#125;<span class="keyword">else</span> low[x]=min(low[x],dfn[y]);</span><br><span class="line">        <span class="keyword">if</span>(low[y]&gt;dfn[x])insert(x,y,G.e[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=G.first[x];i;i=G.e[i].from)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=G.e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(fa[y]!=x&amp;&amp;dfn[y]&gt;dfn[x])solve(x,y,G.e[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=deep[x];j++)f[x][j]=f[f[x][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first[x];i;i=e[i].from)<span class="keyword">if</span>(i!=father)&#123;</span><br><span class="line">        f[e[i].v][<span class="number">0</span>]=x;</span><br><span class="line">        deep[e[i].v]=deep[x]+<span class="number">1</span>;</span><br><span class="line">        dis[e[i].v]=dis[x]+e[i].w;</span><br><span class="line">        dfs(e[i].v,i^<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[x]&lt;deep[y])swap(x,y);</span><br><span class="line">    <span class="keyword">int</span> d=deep[x]-deep[y];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=d;i++)<span class="keyword">if</span>(d&amp;(<span class="number">1</span>&lt;&lt;i))x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&lt;=deep[x]&amp;&amp;f[x][i]!=f[y][i])&#123;</span><br><span class="line">        x=f[x][i];y=f[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    A=x;B=y;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;Q);</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    G.tot=<span class="number">1</span>;tot=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        G.insert(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    N=n;tarjan(<span class="number">1</span>,<span class="number">0</span>);dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        w=lca(u,v);</span><br><span class="line">        <span class="keyword">if</span>(w&lt;=n)<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dis[u]+dis[v]<span class="number">-2</span>*dis[w]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll ans=dis[u]+dis[v]-dis[A]-dis[B];</span><br><span class="line">            <span class="keyword">if</span>(id[A]&lt;id[B])ans+=min(s[A]+s[w]-s[B],s[B]-s[A]);</span><br><span class="line">                <span class="keyword">else</span> ans+=min(s[B]+s[w]-s[A],s[A]-s[B]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="点双"><a href="#点双" class="headerlink" title="点双"></a>点双</h2><p>  对于无向连通图，对每个点双建立一个方点连向其中所有点并消除点双内部的连边，这样就是广义圆方树。</p><p>  例如经典的旅行问题：询问带点权无向图中，两点间所有简单路径的最小权值。</p><p>  两点间的简单路径并=两点间的唯一点双链。（如果存在一条其它路径到达，则与已有点双矛盾。）</p><p>  所以建立广义圆方树后就是查询树链最小值的问题了。（每个方点的权=连接圆点的最小权）</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.cnblogs.com/onioncyc/p/8315835.html" target="_blank" rel="noopener">【算法专题】仙人掌图问题</a></li><li><a href="https://blog.csdn.net/zhangche0526/article/details/71879985" target="_blank" rel="noopener">仙人掌相关问题的处理方法（未完待续）</a></li><li><a href="https://download.csdn.net/download/simpsonk/10172077" target="_blank" rel="noopener">WC2017-immortalCO Making Graph into Trees</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Attention&quot;&gt;&lt;a href=&quot;#Attention&quot; class=&quot;headerlink&quot; title=&quot;Attention&quot;&gt;&lt;/a&gt;Attention&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本文基本转载，极少原创，转载来源见Reference&lt;/li&gt;
&lt;/ul
      
    
    </summary>
    
      <category term="OI/ACM" scheme="https://lixiang-io.cn/categories/OI-ACM/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://lixiang-io.cn/2018/11/02/hello-world/"/>
    <id>https://lixiang-io.cn/2018/11/02/hello-world/</id>
    <published>2018-11-02T13:41:00.000Z</published>
    <updated>2019-02-18T14:12:56.987Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
  </entry>
  
</feed>
